%{
open SlothSQL.Parser.Syntax
open SlothSQL.Parser.Util
%}

// tokens:
%token <Info> SELECT
%token <Info> FROM
%token <Info> WHERE

// identifier:
%token <string> ID
%token <int> INTV
// TODO: identifiers should be of type <string * Info> etc.!

// symbols:
%token <Info> LPAREN
%token <Info> RPAREN
%token <Info> SEMICOLON
%token <Info> COLON
%token <Info> TICK
%token <Info> DOT
%token <Info> EOF

// the parser returns a Syntax.SqlSelectQuery:
%start start
%type <SqlSelectQuery> start

%%

start: query EOF											{ $1 }

query:
	| SELECT selectClause FROM fromClause WHERE whereClause SEMICOLON	{ SelectFromWhere ($2, $4, $6) }
	| SELECT selectClause FROM fromClause SEMICOLON						{ SelectFrom ($2, $4) }

selectClause:
	| columnExpressions										{ Columns (List.rev $1) }
	// TODO: Wildcard

columnExpressions:
	| columnExpr											{ [$1] }
	| columnExpressions COLON columnExpr					{ $3 :: $1 }

columnExpr:
	| ID DOT ID												{ QualifiedColumnExpr ($1, $3) }
	| ID													{ NonQualifiedColumnExpr ($1) }

fromClause:
	| tableExpr COLON tableExpr								{ [$1; $3] } // TODO: more than just 2!
	| tableExpr												{ [$1] }

tableExpr:
	| ID ID													{ $1 } // e.g. FROM contract c
	| ID													{ $1 } // e.g. FROM contract

whereClause:
	| ID													{ $1 }
